use futures::stream::TryStreamExt;
use sqlx::sqlite::SqliteRow;
use sqlx::Row;
use ulid::Ulid;

use crate::{db::DbConnection, entity::FromSqliteRow, queue_manager::setup_queue_manager};

use super::{InPlaylistEntityDto, PlaylistEntity};

pub(crate) struct PlaylistRepo {
    pool: DbConnection,
}

impl PlaylistRepo {
    pub(crate) fn new(pool: DbConnection) -> Self {
        Self { pool }
    }

    pub(crate) fn pool(&self) -> &DbConnection {
        &self.pool
    }

    pub(crate) async fn setup_table(&self) -> Option<PlaylistEntity> {
        let sql = r#"CREATE TABLE "playlists" (
	"internal_id"	INTEGER,
	"id"	TEXT NOT NULL UNIQUE,
	"name"	TEXT NOT NULL UNIQUE,
	"description"	TEXT,
	PRIMARY KEY("internal_id" AUTOINCREMENT)
);"#;

        if sqlx::query(sql).execute(self.pool()).await.is_ok() && !self.has_default_playlist().await
        {
            return self.create_default_playlist().await;
        }
        None
    }

    pub(crate) async fn has_default_playlist(&self) -> bool {
        let sql = r#"SELECT COUNT("internal_id") AS total FROM playlists where name = ?"#;

        match sqlx::query(sql)
            .bind("default playlist")
            .map(|row: SqliteRow| row.get::<i64, &str>("total"))
            .fetch_one(self.pool())
            .await
        {
            Ok(total) => total > 0,
            _ => false,
        }
    }

    pub(crate) async fn create_default_playlist(&self) -> Option<PlaylistEntity> {
        let name = "default playlist";
        let playlist = PlaylistEntity::new(
            name,
            Some("Default playlist generated by the app".to_string()),
        );

        self.create(playlist.into()).await
    }

    pub(crate) async fn create(&self, playlist: InPlaylistEntityDto) -> Option<PlaylistEntity> {
        let sql = r#"INSERT INTO playlists (id, name, description) values (?, ?, ?)"#;

        let id = Ulid::new().to_string().to_lowercase();

        if sqlx::query(sql)
            .bind(&id)
            .bind(playlist.name)
            .bind(playlist.description.unwrap_or_default())
            .execute(self.pool())
            .await
            .is_ok()
        {
            self.find_by_id(&id).await
        } else {
            None
        }
    }

    pub(crate) async fn update(
        &self,
        id: &str,
        playlist: InPlaylistEntityDto,
    ) -> Option<PlaylistEntity> {
        let sql = "UPDATE playlists set name = ?, description = ?";

        if let Some(existing) = self.find_by_id(id).await {
            _ = sqlx::query(sql)
                .bind(playlist.name)
                .bind(playlist.description.unwrap_or(existing.description))
                .execute(self.pool())
                .await;
            return self.find_by_id(id).await;
        }

        None
    }

    pub(crate) async fn find_by_id(&self, id: &str) -> Option<PlaylistEntity> {
        if let Ok(row) = sqlx::query("SELECT * FROM playlists WHERE id = ? ")
            .bind(id)
            .map(PlaylistEntity::from_row)
            .fetch_one(self.pool())
            .await
        {
            row
        } else {
            None
        }
    }
}
